/* main.c : CAN
 * Tue May  9 20:58:59 2017	Warren W. Gay VE3WWG
 * Uses CAN on PB8/PB9, UART1 115200,"8N1","rw",1,1
 *
 * GPIO:
 * ----
 * TX	A9  ====> RX of TTL serial adapter
 * RX	A10 <==== TX of TTL serial adapter
 * CTS	A11 ====> RTS of TTL serial
 * RTS	A12 <==== CTS of TTL serial
 * PB8	CAN_RX (NOTE: Differs from front/rear.c)
 * PB9	CAN_TX (NOTE: Differs from front/rear.c)
 */
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/adc.h>
#include <libopencm3/stm32/spi.h>

#include "FreeRTOS.h"
#include "semphr.h"
#include "mcuio.h"
#include "miniprintf.h"
#include "canmsgs.h"
#include "monitor.h"

#include "ugui.h"
#include "oled_drv.h"
#include "oled.h"

// indent -gnu -br -cli2 -lp -nut -l100 main.c

#define FLASH_MS		400     // Signal flash time in ms
#define GPIO_PORT_LED		GPIOC   // Builtin LED port
#define GPIO_LED		GPIO12  // Builtin LED

static SemaphoreHandle_t mutex; // Handle to mutex
struct s_lamp_status lamp_status = { 0, 0, 0, 0, 0, 0 };

static volatile bool show_rx = true;    // false;
void sleep (int ms);

int my_spi = SPI1;

void show_console (void);
int rot_position = 37;

void
sleep (int ms)
{
  int i, k;
  for (k = 0; k < ms; k++) {
    for (i = 0; i < 1000; i++);
  }
}

void
oled_command (uint8_t byte)
{
  gpio_clear (GPIOB, GPIO10);   // D/C pin
  spi_enable (my_spi);
  spi_xfer (my_spi, byte);
  spi_disable (my_spi);
}

void
oled_command2 (uint8_t byte, uint8_t byte2)
{
  gpio_clear (GPIOB, GPIO10);
  spi_enable (my_spi);
  spi_xfer (my_spi, byte);
  spi_xfer (my_spi, byte2);
  spi_disable (my_spi);
}

void
oled_data (uint8_t byte)
{
  gpio_set (GPIOB, GPIO10);
  spi_enable (my_spi);
  spi_xfer (my_spi, byte);
  spi_disable (my_spi);
}

static void
oled_reset (void)
{
  gpio_clear (GPIOB, GPIO11);   // Reset pin
  sleep (10);
  gpio_set (GPIOB, GPIO11);
}

static void
oled_init (void)
{
  static uint8_t cmds[] = {
    0xAE, 0x00, 0x10, 0x40, 0x81, 0xCF, 0xA1, 0xA6,
    0xA8, 0x3F, 0xD3, 0x00, 0xD5, 0x80, 0xD9, 0xF1,
    0xDA, 0x12, 0xDB, 0x40, 0x8D, 0x14, 0xAF, 0xFF
  };

  gpio_clear (GPIOC, GPIO12);
  oled_reset ();
  for (unsigned ux = 0; cmds[ux] != 0xFF; ++ux) {
    oled_command (cmds[ux]);
  }
  gpio_set (GPIOC, GPIO12);
}


/*********************************************************************
 * CAN Receive Callback
 *********************************************************************/
void
can_recv (struct s_canmsg *msg)
{

  if (show_rx) {
    std_printf ("[%4u(%d/%u):%c,$%02X]\n",
                (unsigned) msg->msgid,
                msg->fifo, (unsigned) msg->fmi, msg->rtrf ? 'R' : 'D', msg->data[0]);
  }

  if (!msg->rtrf) {
    switch (msg->msgid) {
      case ID_Temp:
        break;
      default:
        break;
    }
  }
}

/*********************************************************************
 * Signal Flash task
 *********************************************************************/

static void
flash_task (void *arg __attribute__ ((unused)))
{
  for (;;) {
    gpio_toggle (GPIOC, GPIO12);
    vTaskDelay (pdMS_TO_TICKS (100));
  }
}

static void
oled_task (void *arg __attribute__ ((unused)))
{
  char buf[20];
  static int cntr = 0;

  oled_init ();
  oled_init_real ();

//      UG_FontSelect(&FONT_8X12);
//      UG_FontSelect(&FONT_12X16);
  UG_FontSelect (&FONT_8X14);
  UG_SetBackcolor (C_BLACK);
  UG_SetForecolor (C_WHITE);

  for (;;) {
    UG_FillScreen (C_BLACK);
    mini_snprintf (buf, sizeof buf, "Trim1: %d", rot_position++);
    UG_PutString (0, 0, buf);
    mini_snprintf (buf, sizeof buf, "Trim2: %d", rot_position++);
    UG_PutString (0, 15, buf);
    mini_snprintf (buf, sizeof buf, "Trim3: %d", rot_position++);
    UG_PutString (0, 30, buf);
    mini_snprintf (buf, sizeof buf, "Trim4: %d", cntr++);
    UG_PutString (0, 45, buf);
    oled_update ();
    vTaskDelay (500);
  }
}


/*********************************************************************
 * Console:
 *********************************************************************/
static void
console_task (void *arg __attribute__ ((unused)))
{
  static bool lockedf, flashf = false;
  struct s_lamp_en msg;
  char ch;

  xSemaphoreTake (mutex, portMAX_DELAY);        // Initialize this as locked
  lockedf = true;

  std_printf ("Car simulation begun.\n");
//      show_menu();
  std_printf ("CAN Console Ready:\n");


  for (;;) {
    std_printf ("> ");
    ch = std_getc ();
    std_printf ("%c\n", ch);

    switch (ch) {
      case 'F':
      case 'f':
        msg.enable = false;     // Not used here
        msg.reserved = 0;
        can_xmit (ID_Flash, false, false, sizeof msg, &msg);
        break;
      case 'L':
      case 'l':
        lamp_status.left = ch == 'L';
//                      lamp_enable(ID_LeftEn,lamp_status.left);
        flashf = true;
        break;
      case 'R':
      case 'r':
        lamp_status.right = ch == 'R';
//                      lamp_enable(ID_RightEn,lamp_status.right);
        flashf = true;
        break;
      case 'P':
      case 'p':
        lamp_status.park = ch == 'P';
//                      lamp_enable(ID_ParkEn,lamp_status.park);
        break;
      case 'b':
      case 'B':
        lamp_status.brake = ch == 'B';
//                      lamp_enable(ID_BrakeEn,lamp_status.brake);
        break;
      case 'V':
      case 'v':
        // Toggle show messages received (verbose mode)
        show_rx ^= true;
        break;
      case '\r':
        break;
//              default:
    }


    if (flashf) {
      if ((lamp_status.left || lamp_status.right) && lockedf) {
        xSemaphoreGive (mutex); // Start flasher
        lockedf = false;
      }
      else if (!lockedf && !lamp_status.left && !lamp_status.right) {
        xSemaphoreTake (mutex, portMAX_DELAY);  // Stop flasher
        lockedf = true;
      }
      flashf = false;
    }
  }
}

/*********************************************************************
 * Main program: Device initialization etc.
 *********************************************************************/
int
main (void)
{

  rcc_clock_setup_in_hse_8mhz_out_72mhz ();  // Use this for "blue pill"

  rcc_periph_clock_enable (RCC_GPIOC);
  gpio_set_mode (GPIO_PORT_LED, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO_LED);
  
  rcc_periph_clock_enable (RCC_GPIOA);  
  rcc_periph_clock_enable (RCC_GPIOB);
  rcc_periph_clock_enable (RCC_AFIO);

  gpio_set_mode (GPIOA, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART2_TX);
  std_set_device (mcu_uart2);   // Use UART1 for std I/O
  open_uart (2, 115200, "8N1", "rw", 0, 0);

//  gpio_set_mode (GPIOA, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO11);

#if 0
 // SPI 1
 rcc_periph_clock_enable (RCC_SPI1);  
 // PB10 -> D/C, PB11 -> RES
  gpio_set_mode (GPIOB, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO10 | GPIO11);
  // Activate OLED Reset line
  gpio_clear (GPIOB, GPIO11);

  // PA7=MOSI, PA5=SCK
  gpio_set_mode (GPIOA, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO7 | GPIO5);
  // NSS=PA15
  gpio_set_mode (GPIOA, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO4);

  spi_reset (SPI1);
  spi_init_master (SPI1,
                   SPI_CR1_BAUDRATE_FPCLK_DIV_256,
                   SPI_CR1_CPOL_CLK_TO_0_WHEN_IDLE,
                   SPI_CR1_CPHA_CLK_TRANSITION_1, SPI_CR1_DFF_8BIT, SPI_CR1_MSBFIRST);
  spi_disable_software_slave_management (SPI1);
  spi_enable_ss_output (SPI1);
  my_spi = SPI1;
#endif

#if 1
 // SPI 2
 rcc_periph_clock_enable (RCC_SPI2);  
 // PB10 -> D/C, PB11 -> RES
  gpio_set_mode (GPIOB, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO10 | GPIO11);
  // Activate OLED Reset line
  gpio_clear (GPIOB, GPIO11);

  // PB15=MOSI, PB13=SCK, NSS=PB12
  gpio_set_mode (GPIOB, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO13 | GPIO15 | GPIO12);

  gpio_set_mode (GPIOB, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT, GPIO14);  // MISO=PB14

  spi_reset (SPI2);
  spi_init_master (SPI2,
                   SPI_CR1_BAUDRATE_FPCLK_DIV_256,
                   SPI_CR1_CPOL_CLK_TO_0_WHEN_IDLE,
                   SPI_CR1_CPHA_CLK_TRANSITION_1, SPI_CR1_DFF_8BIT, SPI_CR1_MSBFIRST);
  spi_disable_software_slave_management (SPI2);
  spi_enable_ss_output (SPI2);
  my_spi = SPI2;
#endif


  initialize_can (false, true, true);   // !nart, locked, altcfg=true PB8/PB9

  xTaskCreate (console_task, "console", 200, NULL, configMAX_PRIORITIES - 1, NULL);

  mutex = xSemaphoreCreateMutex ();
  xTaskCreate (flash_task, "flash", 100, NULL, configMAX_PRIORITIES - 1, NULL);

  xTaskCreate (oled_task, "oled", 300, NULL, configMAX_PRIORITIES - 1, NULL);

  vTaskStartScheduler ();
  for (;;);
}

// End main.c
